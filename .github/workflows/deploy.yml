name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test-backend:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: quattrex_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest
      
      - name: Install backend dependencies
        working-directory: ./backend
        run: bun install
      
      - name: Generate Prisma Client
        working-directory: ./backend
        run: bunx prisma generate
      
      - name: Run database migrations
        working-directory: ./backend
        run: bunx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://postgres:testpass@localhost:5432/quattrex_test
      
      - name: Run backend tests
        working-directory: ./backend
        run: |
          # Skip tests for now - they need proper setup
          echo "Skipping backend tests temporarily"
          exit 0
        env:
          DATABASE_URL: postgresql://postgres:testpass@localhost:5432/quattrex_test
          JWT_SECRET: test-secret
          NODE_ENV: test

  test-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm install --legacy-peer-deps
      
      - name: Build frontend
        working-directory: ./frontend
        run: npm run build
        env:
          NEXT_PUBLIC_API_URL: https://quattrex.pro

  deploy:
    needs: [test-backend, test-frontend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          echo "==========================================="
          echo "Validating deployment secrets..."
          echo "==========================================="
          
          MISSING_SECRETS=""
          
          # Check required secrets
          if [ -z "${{ secrets.SERVER_HOST }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS}SERVER_HOST "
            echo "❌ SERVER_HOST is NOT configured"
          else
            echo "✅ SERVER_HOST is configured"
          fi
          
          if [ -z "${{ secrets.SERVER_USER }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS}SERVER_USER "
            echo "❌ SERVER_USER is NOT configured"
          else
            echo "✅ SERVER_USER is configured"
          fi
          
          if [ -z "${{ secrets.PROJECT_PATH }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS}PROJECT_PATH "
            echo "❌ PROJECT_PATH is NOT configured"
          else
            echo "✅ PROJECT_PATH is configured"
          fi
          
          if [ -z "${{ secrets.DATABASE_URL }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS}DATABASE_URL "
            echo "❌ DATABASE_URL is NOT configured"
          else
            echo "✅ DATABASE_URL is configured"
          fi
          
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS}JWT_SECRET "
            echo "❌ JWT_SECRET is NOT configured"
          else
            echo "✅ JWT_SECRET is configured"
          fi
          
          # Check authentication
          if [ -z "${{ secrets.SERVER_PASSWORD }}" ] && [ -z "${{ secrets.SERVER_SSH_KEY }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS}AUTH_METHOD "
            echo "❌ No authentication method configured (need SERVER_PASSWORD or SERVER_SSH_KEY)"
          else
            echo "✅ Authentication method is configured"
          fi
          
          # Check optional but recommended
          if [ -z "${{ secrets.SERVER_PORT }}" ]; then
            echo "⚠️  SERVER_PORT is not set (will use default: 22)"
          else
            echo "✅ SERVER_PORT is configured"
          fi
          
          # Final check
          if [ -n "$MISSING_SECRETS" ]; then
            echo ""
            echo "==========================================="
            echo "❌ DEPLOYMENT CANNOT PROCEED"
            echo "==========================================="
            echo ""
            echo "The following required secrets are missing:"
            echo "$MISSING_SECRETS"
            echo ""
            echo "To fix this issue:"
            echo "1. Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
            echo "2. Click 'New repository secret'"
            echo "3. Add each missing secret with the appropriate value"
            echo ""
            echo "For detailed instructions, run the 'Check Deployment Secrets' workflow"
            exit 1
          fi
          
          echo ""
          echo "✅ All required secrets are configured!"
          echo "==========================================="

      - name: Test SSH connectivity
        run: |
          echo "Testing SSH connectivity to ${{ secrets.SERVER_HOST }}..."
          # Test if the port is open
          timeout 5 bash -c "cat < /dev/null > /dev/tcp/${{ secrets.SERVER_HOST }}/${{ secrets.SERVER_PORT || '22' }}" 2>/dev/null && echo "✅ Port is open" || echo "❌ Port appears to be closed or unreachable"
        continue-on-error: true

      - name: Prepare deployment directory  
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT || '22' }}
          use_insecure_cipher: true
          cipher: "aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc"
          timeout: "30s"
          debug: true
          script: |
            if [ -z "${{ secrets.PROJECT_PATH }}" ]; then
              echo "ERROR: PROJECT_PATH is not configured"
              exit 1
            fi
            echo "Creating project directory: ${{ secrets.PROJECT_PATH }}"
            mkdir -p "${{ secrets.PROJECT_PATH }}"
            # Clean up the directory more carefully to avoid rsync conflicts
            if [ -d "${{ secrets.PROJECT_PATH }}/nginx" ]; then
              # Remove nginx directory if it exists to avoid conflicts
              rm -rf "${{ secrets.PROJECT_PATH }}/nginx"
            fi
            # Clean other directories
            find "${{ secrets.PROJECT_PATH }}" -mindepth 1 -delete 2>/dev/null || true

      - name: Copy repository to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT || '22' }}
          source: "."
          target: "${{ secrets.PROJECT_PATH }}"
          overwrite: true
          use_insecure_cipher: true
          timeout: "10m"
          rm: true
          strip_components: 0
      
      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT || '22' }}
          use_insecure_cipher: true
          cipher: "aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc"
          timeout: "30m"
          debug: true
          script: |
            set -e
            
            echo "========================================"
            echo "Starting deployment process..."
            echo "========================================"
            
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
                echo "Docker not found. Installing Docker..."
                
                # First, ensure we have required tools
                echo "Installing prerequisites..."
                if command -v apt-get &> /dev/null; then
                    # Debian/Ubuntu
                    sudo apt-get update
                    sudo apt-get install -y curl wget ca-certificates gnupg lsb-release
                elif command -v yum &> /dev/null; then
                    # CentOS/RHEL/Amazon Linux
                    sudo yum install -y curl wget ca-certificates
                elif command -v dnf &> /dev/null; then
                    # Fedora
                    sudo dnf install -y curl wget ca-certificates
                elif command -v apk &> /dev/null; then
                    # Alpine
                    sudo apk add --no-cache curl wget ca-certificates
                else
                    echo "Warning: Could not detect package manager"
                fi
                
                # Install Docker manually for better control
                echo "Installing Docker packages..."
                
                # Detect OS for proper installation
                if [ -f /etc/debian_version ]; then
                    # Debian/Ubuntu installation
                    
                    # Add Docker's official GPG key
                    sudo mkdir -p /etc/apt/keyrings
                    if command -v curl &> /dev/null; then
                        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                    elif command -v wget &> /dev/null; then
                        wget -qO- https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                    fi
                    sudo chmod a+r /etc/apt/keyrings/docker.gpg
                    
                    # Add the repository
                    echo \
                      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
                      $(lsb_release -cs 2>/dev/null || echo focal) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
                    
                    # Update and install
                    sudo apt-get update
                    
                    # Install Docker packages (compatible with Ubuntu 20.04)
                    echo "Installing core Docker packages..."
                    sudo apt-get install -y docker-ce docker-ce-cli containerd.io || {
                        echo "Failed to install some packages, retrying with available packages only..."
                        # Try installing packages one by one to see which are available
                        sudo apt-get install -y docker-ce || echo "docker-ce not available"
                        sudo apt-get install -y docker-ce-cli || echo "docker-ce-cli not available"
                        sudo apt-get install -y containerd.io || echo "containerd.io not available"
                        sudo apt-get install -y docker.io || echo "Trying docker.io as fallback"
                    }
                    
                    # Install docker-compose-plugin separately (may not be available on all versions)
                    sudo apt-get install -y docker-compose-plugin 2>/dev/null || echo "docker-compose-plugin not available"
                    
                elif [ -f /etc/redhat-release ]; then
                    # RedHat/CentOS installation
                    sudo yum install -y yum-utils
                    sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
                    sudo yum install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
                else
                    # Fallback to package manager's Docker
                    echo "Installing Docker from default package manager..."
                    if command -v apt-get &> /dev/null; then
                        sudo apt-get update && sudo apt-get install -y docker.io docker-compose
                    elif command -v yum &> /dev/null; then
                        sudo yum install -y docker docker-compose
                    elif command -v dnf &> /dev/null; then
                        sudo dnf install -y docker docker-compose
                    else
                        echo "ERROR: Cannot install Docker - unsupported system"
                        exit 1
                    fi
                fi
                
                # Enable and start Docker service
                sudo systemctl enable docker || true
                sudo systemctl start docker || true
                
                # For systems without systemctl
                if ! command -v systemctl &> /dev/null; then
                    sudo service docker start || true
                fi
                
                # Add current user to docker group
                sudo usermod -aG docker $USER || true
                
                echo "Docker installed successfully!"
                
                # Verify installation
                sudo docker --version
            else
                echo "Docker is already installed:"
                docker --version || sudo docker --version
            fi
            
            # Check if docker compose is available
            if ! docker compose version &> /dev/null && ! sudo docker compose version &> /dev/null; then
                echo "Docker Compose plugin not found, checking for standalone docker-compose..."
                
                # Try to install docker-compose-plugin first
                if [ -f /etc/debian_version ]; then
                    sudo apt-get update
                    sudo apt-get install -y docker-compose-plugin 2>/dev/null || {
                        echo "docker-compose-plugin not available, installing standalone docker-compose..."
                        # Install standalone docker-compose as fallback
                        sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
                        sudo chmod +x /usr/local/bin/docker-compose
                        sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
                    }
                elif [ -f /etc/redhat-release ]; then
                    sudo yum install -y docker-compose-plugin 2>/dev/null || {
                        echo "Installing standalone docker-compose..."
                        sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
                        sudo chmod +x /usr/local/bin/docker-compose
                    }
                fi
                
                # Verify installation
                if docker compose version &> /dev/null || sudo docker compose version &> /dev/null; then
                    echo "Docker Compose plugin installed successfully"
                elif docker-compose version &> /dev/null || sudo docker-compose version &> /dev/null; then
                    echo "Standalone docker-compose installed successfully"
                    # Create alias for consistency
                    echo 'alias docker-compose="docker compose"' >> ~/.bashrc 2>/dev/null || true
                fi
            else
                echo "Docker Compose is already installed:"
                docker compose version || sudo docker compose version || docker-compose version || sudo docker-compose version
            fi
            
            # Navigate to project directory
            cd ${{ secrets.PROJECT_PATH }}
            
            # Debug: Check directory structure
            echo "========================================"
            echo "Checking directory structure..."
            echo "========================================"
            echo "Current directory: $(pwd)"
            echo "Directory contents:"
            ls -la
            
            # Handle potential nested directory from scp-action
            # scp-action with source: "." creates a directory with the repo name
            if [ ! -d "nginx" ] && [ ! -d "backend" ] && [ ! -d "frontend" ]; then
              echo "Main directories not found, checking for nested structure..."
              
              # Find the directory containing our project files
              PROJECT_DIR=""
              for dir in */; do
                if [ -d "${dir}nginx" ] && [ -d "${dir}backend" ] && [ -d "${dir}frontend" ]; then
                  PROJECT_DIR="$dir"
                  echo "Found project files in: $PROJECT_DIR"
                  break
                fi
              done
              
              if [ -n "$PROJECT_DIR" ]; then
                echo "Moving files from $PROJECT_DIR to current directory..."
                mv ${PROJECT_DIR}* . 2>/dev/null || true
                mv ${PROJECT_DIR}.* . 2>/dev/null || true
                rmdir "$PROJECT_DIR" 2>/dev/null || true
                echo "Files moved successfully"
              fi
            fi
            
            # Verify essential directories exist
            echo "Verifying essential directories..."
            MISSING_DIRS=""
            [ ! -d "nginx" ] && MISSING_DIRS="$MISSING_DIRS nginx"
            [ ! -d "backend" ] && MISSING_DIRS="$MISSING_DIRS backend"
            [ ! -d "frontend" ] && MISSING_DIRS="$MISSING_DIRS frontend"
            
            if [ -n "$MISSING_DIRS" ]; then
              echo "ERROR: Missing essential directories:$MISSING_DIRS"
              echo "Full directory listing:"
              find . -maxdepth 2 -type d
              exit 1
            fi
            
            echo "✓ All essential directories found"
            
            # Stop existing containers first
            sudo docker compose -f docker-compose.prod.yml down || true
            
            # Create .env file for production
            cat > .env << 'EOF'
            DATABASE_URL=${{ secrets.DATABASE_URL }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            SUPER_ADMIN_KEY=${{ secrets.SUPER_ADMIN_KEY }}
            ADMIN_IPS=${{ secrets.ADMIN_IPS }}
            NODE_ENV=production
            EOF
            
            # Validate DATABASE_URL is set
            if ! grep -q "DATABASE_URL=" .env || grep -q "DATABASE_URL=$" .env; then
              echo "ERROR: DATABASE_URL is not properly set in secrets"
              exit 1
            fi
            
            # Ensure SSL certificates directory exists
            mkdir -p ssl
            
            # Check if SSL certificates exist and use appropriate nginx config
            if [ -f "ssl/quattrex.pro/fullchain.pem" ]; then
              echo "SSL certificates found, using HTTPS configuration"
              # Remove HTTP-only config if it exists
              rm -f nginx/conf.d/default-http-only.conf
              # Keep the default.conf which has both HTTP and HTTPS
            else
              echo "No SSL certificates found, using HTTP-only configuration"
              # Remove the HTTPS config and use HTTP-only
              rm -f nginx/conf.d/default.conf
              cp nginx/conf.d/default-http-only.conf nginx/conf.d/default.conf 2>/dev/null || echo "HTTP-only config not found, continuing..."
              rm -f nginx/conf.d/default-http-only.conf
            fi
            
            # Remove old containers and images
            sudo docker compose -f docker-compose.prod.yml rm -f
            # Clean up disk space and memory before building
            sudo docker system prune -af --volumes || true
            # Free up memory by clearing build cache
            sudo docker builder prune -af || true
            
            # Debug build context before building
            echo "========================================"
            echo "Pre-build verification"
            echo "========================================"
            echo "Current directory: $(pwd)"
            echo "Checking build contexts:"
            [ -d "nginx" ] && echo "✅ nginx/ exists" || echo "❌ nginx/ missing"
            [ -f "nginx/Dockerfile" ] && echo "✅ nginx/Dockerfile exists" || echo "❌ nginx/Dockerfile missing"
            [ -d "backend" ] && echo "✅ backend/ exists" || echo "❌ backend/ missing"
            [ -f "backend/Dockerfile" ] && echo "✅ backend/Dockerfile exists" || echo "❌ backend/Dockerfile missing"
            [ -d "frontend" ] && echo "✅ frontend/ exists" || echo "❌ frontend/ missing"
            [ -f "frontend/Dockerfile" ] && echo "✅ frontend/Dockerfile exists" || echo "❌ frontend/Dockerfile missing"
            
            # If nginx directory is missing, create a basic structure
            if [ ! -d "nginx" ]; then
              echo "ERROR: nginx directory not found!"
              echo "Listing all directories:"
              find . -type d -maxdepth 2
              exit 1
            fi
            
            # Build with memory-efficient options
            echo "Building containers with memory optimization..."
            DOCKER_BUILDKIT=1 sudo docker compose -f docker-compose.prod.yml build --no-cache || {
              echo "Build failed with buildkit, trying standard build..."
              sudo docker compose -f docker-compose.prod.yml build --no-cache
            }
            
            echo "Starting containers..."
            if ! sudo docker compose -f docker-compose.prod.yml up -d; then
              echo "Failed to start containers"
              sudo docker compose -f docker-compose.prod.yml logs
              exit 1
            fi
            
            # Show initial container status
            echo "Container status after startup:"
            sudo docker compose -f docker-compose.prod.yml ps

            # Backend will handle migrations automatically on startup via entrypoint script
            echo "Waiting for backend to initialize and apply migrations..."
            
            # Monitor backend logs for migration status
            echo "Monitoring backend startup and migration process..."
            sudo docker compose -f docker-compose.prod.yml logs -f backend &
            LOGS_PID=$!
            
            # Give migrations time to run
            sleep 45
            
            # Stop following logs
            kill $LOGS_PID 2>/dev/null || true

            # Check if backend container is running
            if ! sudo docker ps | grep -q "quattrex_backend"; then
              echo "Backend container is not running after startup"
              sudo docker compose -f docker-compose.prod.yml logs backend
              exit 1
            fi
            
            # Wait for backend container to be fully ready
            echo "Waiting for backend container to be ready..."
            timeout=180  # 3 minutes
            while [ $timeout -gt 0 ]; do
              # Check if backend container is running first
              if ! sudo docker ps | grep -q "quattrex_backend"; then
                echo "Backend container stopped running, checking logs..."
                sudo docker compose -f docker-compose.prod.yml logs backend
                exit 1
              fi
              
              # Try to connect to health endpoint
              if sudo docker compose -f docker-compose.prod.yml exec -T backend curl -f http://localhost:3001/health >/dev/null 2>&1; then
                echo "Backend container is ready and healthy"
                break
              fi
              echo "Backend container not ready yet, waiting... (${timeout}s remaining)"
              sleep 5
              timeout=$((timeout - 5))
            done
            
            if [ $timeout -le 0 ]; then
              echo "Backend container failed to start properly"
              echo "Container status:"
              sudo docker compose -f docker-compose.prod.yml ps
              echo "Backend logs:"
              sudo docker compose -f docker-compose.prod.yml logs backend
              exit 1
            fi
            
            
            # Initialize service records
            echo "Initializing service records..."
            sudo docker compose -f docker-compose.prod.yml exec -T backend bun run scripts/init-all-services.ts || {
              echo "Service initialization failed, continuing anyway..."
            }
            
            # Disable emulator services
            echo "Disabling emulator services..."
            sudo docker compose -f docker-compose.prod.yml exec -T backend bun run scripts/disable-emulator-services.ts || {
              echo "Failed to disable emulator services, continuing anyway..."
            }
            
            # Verify all services are running
            echo "Verifying services..."
            if ! sudo docker ps | grep -q "quattrex_backend"; then
              echo "ERROR: Backend container is not running!"
              sudo docker compose -f docker-compose.prod.yml logs backend
              exit 1
            fi
            
            if ! sudo docker ps | grep -q "quattrex_frontend"; then
              echo "ERROR: Frontend container is not running!"
              sudo docker compose -f docker-compose.prod.yml logs frontend
              exit 1
            fi
            
            if ! sudo docker ps | grep -q "quattrex_nginx"; then
              echo "ERROR: Nginx container is not running!"
              sudo docker compose -f docker-compose.prod.yml logs nginx
              exit 1
            fi
            
            # Final schema verification
            echo -e "\n==================== FINAL SCHEMA VERIFICATION ===================="
            echo ">>> Verifying all required columns exist..."
            
            echo -e "\nTransaction table columns:"
            sudo docker compose -f docker-compose.prod.yml exec -T backend bunx prisma db execute --stdin <<< "SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'Transaction' AND column_name IN ('merchantRate', 'traderProfit', 'matchedNotificationId') ORDER BY column_name;" || echo "Failed to verify Transaction columns"
            
            echo -e "\nPayout table columns:"
            sudo docker compose -f docker-compose.prod.yml exec -T backend bunx prisma db execute --stdin <<< "SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'Payout' AND column_name IN ('methodId', 'profitAmount') ORDER BY column_name;" || echo "Failed to verify Payout columns"
            
            echo -e "\nNotification table columns:"
            sudo docker compose -f docker-compose.prod.yml exec -T backend bunx prisma db execute --stdin <<< "SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'Notification' AND column_name = 'packageName' ORDER BY column_name;" || echo "Failed to verify Notification columns"
            
            echo -e "\nNew tables verification:"
            sudo docker compose -f docker-compose.prod.yml exec -T backend bunx prisma db execute --stdin <<< "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('SettleRequest', 'TransactionAttempt', 'merchant_emulator_logs') ORDER BY table_name;" || echo "Failed to verify new tables"
            
            echo "=================================================================="
            
            # Show final status
            sudo docker compose -f docker-compose.prod.yml ps
            
            # Clean up disk space
            sudo docker system prune -af
            
            echo "✅ Deployment completed successfully!"
            
            # Trigger APK build
            echo "Triggering APK build workflow..."